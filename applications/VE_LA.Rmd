```{r imports}
rm(list = ls())

# setwd("C:/Users/Gabriel/Documents/Gabriel/IC/R/")

source("blockNNGPrgeneric.R")
source("Irregblock.R")
source("utils.R")

library(terra)
library(sf)
library(dplyr)
library(ggplot2)
require(Matrix)
library(INLA)
```

```{r}
n.partition <- 4
n.blocks <- n.partition^2
num.nb <- 2

priors = list(
  a = 0,
  b = 39.859
)
alpha <- 0.8
```


```{r AEREAL-DATA cache=TRUE}
# Get world PM2.5 concentration
world_data <- c(
  rast("./CA_data/aereal_PM25_CA_2010/aereal_PM25_CA_2010.tif"),
  rast("./CA_data/aereal_PM25_CA_2011/aereal_PM25_CA_2011.tif"),
  rast("./CA_data/aereal_PM25_CA_2012/aereal_PM25_CA_2012.tif")
)

ventura <- st_read("CA_data/VE_shp/VE.shp")
los_angeles <- st_read("CA_DATA/LA_shp/LA.shp")
ventura$county <- "Ventura"
los_angeles$county <- "Los Angeles"

shapefile <- rbind(ventura, los_angeles)

shapefile <- st_transform(shapefile, crs(world_data)) # sync CRS
aerealData <- crop(world_data, shapefile) # crop to fit (?)
aerealData <- mask(aerealData, shapefile) # mask shapefile with data
aerealData <- mean(aerealData, na.rm = TRUE) # get mean

aerealData_sf <- st_as_sf(as.polygons(aerealData$mean))
#  ! use pipe operator
```

```{r POINT-DATA cache=TRUE}
fileList <- list.files(
  path = "./CA_data/point_PM25_CA_2012", #
  pattern = "\\.csv$",
  full.names = TRUE
)

# Get California point Data
pointData <- lapply(fileList, function(file) {
  f <- st_read(
    file,
    options = c(
      "X_POSSIBLE_NAMES=Site.Longitude",
      "Y_POSSIBLE_NAMES=Site.Latitude"
    ),
    crs = 4326 # Define o CRS como WGS84
  )
  return(f)
})

#  Get mean values
#  Cada estação possuí várias medidas ao longo do ano, o que faremos é tirar a média de todas
#  as medidas dentro de um ano, e então tirar a média de todos os anos, assim, cada estação
#  terá apenas uma medida, que é a média total

#  "Daily.Mean.PM2.5.Concentration", "Site.Latitude", "Site.Longitude"

annual_means <- lapply(pointData, function(df) {
  # Converter para numérico se necessário
  if (!is.numeric(df$Daily.Mean.PM2.5.Concentration)) {
    df$Daily.Mean.PM2.5.Concentration <- as.numeric(as.character(
      df$Daily.Mean.PM2.5.Concentration
    ))
  }

  # Calcular médias por estação
  result <- df %>%
    group_by(Site.Latitude, Site.Longitude, Site.ID) %>%
    summarise(
      Annual_Mean = mean(Daily.Mean.PM2.5.Concentration, na.rm = TRUE),
      Count = sum(!is.na(Daily.Mean.PM2.5.Concentration)),
      .groups = "drop"
    )

  # Converter para objeto sf com geometria
  if (inherits(df, "sf")) {
    result <- st_as_sf(
      result,
      coords = c("Site.Longitude", "Site.Latitude"),
      crs = st_crs(df)
    )
  } else {
    # Se não for objeto sf, criar geometria manualmente
    result <- st_as_sf(
      result,
      coords = c("Site.Longitude", "Site.Latitude"),
      crs = 4326 # WGS84 como sistema padrão
    )
  }

  return(result)
})

all_stations <- do.call(rbind, annual_means)

#  Get total mean
pointData_df <- all_stations %>%
  group_by(Site.ID) %>%
  summarise(
    mean = mean(Annual_Mean, na.rm = TRUE),
    .groups = "drop"
  )
```

```{r Join-spatial-data}
# Filtra apenas polígonos com valor (sem NA)
aereal_polygons <- aerealData_sf[!is.na(aerealData_sf$mean), ]

# Faz interseção espacial com os pontos - Isso retorna apenas os pontos que estão dentro de algum polígono válido
points_on_aereal <- st_join(pointData_df, aereal_polygons, join = st_within)

# Remove pontos que não caíram em nenhum polígono (ou seja, ficaram com NA no join)
points_on_aereal <- points_on_aereal[!is.na(points_on_aereal$mean.y), ]

# Junta os dados selecionados
mixedData <- bind_rows(
  aerealData = select(aereal_polygons, mean, geometry),
  pointData = select(points_on_aereal, mean = mean.x, geometry),
  .id = "type"
)

sf <- st_transform(st_sf(mixedData$geometry), 4326)
sf <- st_make_valid(sf)

# plot(mixedData)
```

```{r Get-model cache=TRUE}
HGPdata <- get_HGPdata(sf, n.blocks, num.nb, alpha, priors)
HGPdata <- get_HGPdata(sf, n.blocks, num.nb, alpha, priors)

y <- mixedData$mean[HGPdata$order]

# View(mixedData)
```

```{r Run-INLA cache=TRUE}
# {r Run-INLA (Versão Corrigida)}

# 1. Organizar os dados (usando a variável 'y' JÁ REORDENADA)
# ----------------------------------------------------
data1 <- data.frame(y = y) # CORREÇÃO: Usar 'y' reordenado
data1$idx <- 1:nrow(data1)

# 2. Definir a fórmula do modelo
# ----------------------------------------------------
# O modelo não possui covariáveis, apenas um intercepto e o efeito espacial
f.spatial <- y ~ 1 + f(idx, model = HGPdata$model)

# 3. Medir o tempo e rodar o INLA
# ----------------------------------------------------
cat("Ajustando o modelo INLA (pode levar alguns minutos)...\n")
tempo_de_ajuste <- system.time({
  resf <- inla(
    f.spatial,
    data = as.data.frame(data1),
    family = "gaussian",
    # Adicionar controle para calcular WAIC e DIC para avaliação do modelo
    control.compute = list(dic = TRUE, waic = TRUE)
  )
})

# 4. Extrair resultados de forma CORRETA e apresentar
# ----------------------------------------------------
cat("\n--- Extraindo e processando os resultados ---\n")

# Intercepto (nível médio de PM2.5)
beta0.est <- resf$summary.fixed["(Intercept)", "mean"]

# Parâmetros de variância
# Tau: Desvio padrão do erro de medição (nugget)
# A precisão (hyperpar[1]) é 1/tau^2. Para obter tau, fazemos 1/sqrt(precisão).
tau.est <- inla.emarginal(
  function(x) 1 / sqrt(x),
  resf$marginals.hyperpar[[1]]
)

# Sigma: Desvio padrão do efeito espacial
# A transformação exp(-x) vem da definição do modelo rgeneric
sigmasq.est <- inla.emarginal(
  function(x) exp(-x),
  resf$marginals.hyperpar[[2]]
)
sigma.est <- sqrt(sigmasq.est)

# Parâmetros de dependência espacial
# CORREÇÃO: Primeiro estimamos phi na escala (0,1), depois calculamos rho
# Phi: Parâmetro de decaimento (escala 0-1)
phi.est <- inla.emarginal(
  function(x) 1 - 1 / (1 + exp(x)), # plogis(x)
  resf$marginals.hyperpar[[3]]
)

# Rho: Alcance prático, derivado de phi
rho.est <- log(10)^(1 / alpha) * phi.est
show_results(resf)
```

```{r Plot-mixed-data}
ggplot() +
  geom_sf(data = mixedData, aes(color = mean, fill = mean)) +
  labs(title = "") +
  theme_minimal()
```
