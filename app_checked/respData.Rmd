```{r} INIT
rm(list = ls())

source("blockNNGPrgeneric.R")
source("Irregblock.R")
source("utils.R")

library(INLA)
library(tidyverse)
require(Matrix)
library(sf)

# dados usados pelo Lucas
library(CARBayesdata)
data(GGHB.IZ)
data(respiratorydata)
```


```{r}
n.partition <- 4
n.blocks <- n.partition^2
num.nb <- 2

alpha <- 0.7
priors = list(a = 0, b = 10)
M = 3
```


```{r} Get aereal mixed data and extract features
sf <- GGHB.IZ[GGHB.IZ$IZ %in% respiratorydata$IZ, ]["geometry"]
n <- nrow(sf)

y <- respiratorydata$observed
X <- as.matrix(cbind(1, scale(respiratorydata$incomedep))) ## X = intercept + covariate
E <- respiratorydata$expected # offset
```


```{r} Generate HGP model
HGPdata <- get_HGPdata(sf, n.blocks, num.nb, alpha, priors)

y <- y[(HGPdata$order)]
X <- X[(HGPdata$order), ]
E <- E[(HGPdata$order)]
blockNNGP.model <- HGPdata$model
```


```{r} Run model with INLA
# 1. Preparar os dados para o INLA
# ----------------------------------------------------
data1 <- data.frame(y = y, x = X[, 2])
data1$idx <- 1:nrow(data1)
f.blockNNGP <- y ~ 1 + x + f(idx, model = blockNNGP.model)

# ----------------------------------------------------
exec_time = system.time({
  resf <- inla(
    f.blockNNGP,
    data = as.data.frame(data1),
    family = "poisson",
    E = E,
    # É uma boa prática adicionar este controle para calcular estatísticas de ajuste
    control.compute = list(dic = TRUE, waic = TRUE)
  )
})
# 3. Extrair e transformar os resultados
# ----------------------------------------------------
# Efeitos fixos (Intercepto e covariável)
beta.est <- resf$summary.fixed[, "mean"]
names(beta.est) <- rownames(resf$summary.fixed)

# Variância do efeito espacial (sigma.sq)
sigmasq.est <- inla.emarginal(
  function(x) exp(-x),
  resf$marginals.hyperpar[[1]]
)

# Parâmetro de decaimento (phi)
phi.est <- inla.emarginal(
  function(x) 1 - 1 / (1 + exp(x)),
  resf$marginals.hyperpar[[2]]
)

# Parâmetro de alcance espacial (rho)
rho.est <- log(10)^(1 / alpha) * phi.est

# Efeito espacial estimado para cada área
est.w <- resf$summary.random$idx$mean
```


```{r}
# Adicionar informação dos blocos ao objeto sf
sf$block <- HGPdata$blocks
sf$y <- y
centroids <- st_centroid(sf)


# Plotar blocos coloridos
ggplot(sf) +
  geom_sf(aes(fill = factor(block)), color = "white", alpha = 0.8) +
  scale_fill_discrete(name = "Bloco") +
  labs(title = "Divisão Espacial em Blocos") +
  theme_minimal()


# Mapa de calor da variável y
ggplot(sf) +
  geom_sf(aes(fill = y), color = NA) +
  scale_fill_viridis_c(name = "Casos Observados") +
  labs(title = "Distribuição Espacial dos Casos de Doenças Respiratórias") +
  theme_minimal()
```

```{r}
show_results(res)
```
