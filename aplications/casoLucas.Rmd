```{r} INIT
rm(list = ls())
# set.seed(1232)
# setwd("./R/fix_nu")

source("blockNNGPrgeneric.R")
source("Irregblock.R")
source("utils.R")

library(INLA)
library(mvtnorm)
library(tidyverse)
library(sf)

# dados usados pelo Lucas
library(CARBayesdata)
data(GGHB.IZ)
data(respiratorydata)
```

```{r} Get aereal mixed data and extract features
sf <- GGHB.IZ[GGHB.IZ$IZ %in% respiratorydata$IZ, ]["geometry"]
n <- nrow(sf)

y <- respiratorydata$observed
x <- as.matrix(cbind(1, scale(respiratorydata$incomedep))) ## X = intercept + covariate
E <- respiratorydata$expected # offset
typeof(sf)

```


```{r} Generate HGP model
n.partition <- 4
n.blocks <- n.partition^2
num.nb <- 2

alpha <- 0.7
HGPdata <- get_HGPdata(
  sf,
  n.blocks,
  num.nb,
  priors = list(a = 0, b = 7),
  alpha = alpha
)

y <- y[(HGPdata$order)]
x <- x[(HGPdata$order), ]
E <- E[(HGPdata$order)]
blockNNGP.model <- HGPdata$model
```




```{r} Run model with INLA'
data1 <- data.frame(y = y, x = x[, 2], idx = i:n)

f.blockNNGP <- y ~ 1 + x + f(idx, model = blockNNGP.model)
# f.blockNNGP <- y ~ 1 + x + f(idx, model = blockNNGP.model)

M <- 10
out <- matrix(0, ncol = 4, nrow = M)
results_list = list()

for (i in 1:M) {
  set.seed(i)
  print(i)

  resf <- inla(
    f.blockNNGP,
    data = as.data.frame(data1),
    family = "poisson",
    E = E
  )

  summary(resf)

  sigmasq.est <- inla.emarginal(
    function(x) exp(-x),
    resf$marginals.hyperpar[[1]]
  )

  # Theta2 = logit(ϕ) -> rho = log(10)^1/ν * φ
  rho.est <- inla.emarginal(
    function(x) log(10)^(1 / (alpha)) * (10 - (10) / (1 + exp(x))),
    resf$marginals.hyperpar[[2]]
  )

  est.w <- resf$summary.random$idx$mean

  # Resultado transformado
  cat("beta:", resf$summary.fixed[, 1], resf$summary.fixed[, 2], "\n")
  cat("σ²:", sigmasq.est, "\n")
  cat("ϕ :", rho.est, "\n")

  summary(resf)

  out[i, ] <- c(resf$summary.fixed[, 1], sigmasq.est, rho.est)

  results_list[[i]] <- list(
    beta = resf$summary.fixed,
    sigmasq = sigmasq.est,
    rho = rho.est,
    w_mean = est.w
  )
}

summary(out)
```


```{r}
# Extrair centróides dos polígonos
centroids <- st_centroid(sf)

# Plotar polígonos e centróides
ggplot() +
  geom_sf(data = sf, fill = "lightblue", color = "black", alpha = 0.5) + # Polígonos
  geom_sf(data = centroids, color = "red", size = 2) + # Centróides
  labs(title = "Áreas e Centróides das Zonas de Integração (IZ)") +
  theme_minimal()

# Adicionar informação dos blocos ao objeto sf
sf$block <- HGPdata$blocks

# Plotar blocos coloridos
ggplot(sf) +
  geom_sf(aes(fill = factor(block)), color = "white", alpha = 0.8) +
  scale_fill_discrete(name = "Bloco") +
  labs(title = "Divisão Espacial em Blocos") +
  theme_minimal()


# Adicionar dados de y ao objeto sf
sf$y <- y

# Mapa de calor da variável y
ggplot(sf) +
  geom_sf(aes(fill = y), color = NA) +
  scale_fill_viridis_c(name = "Casos Observados") +
  labs(title = "Distribuição Espacial dos Casos de Doenças Respiratórias") +
  theme_minimal()
```



```{r}
# Calcular phi
distMat <- st_distance(sf) |>
  set_units("km")

rho = max(distMat) / 2
phi = rho / (log(10)^(1 / alpha))
```